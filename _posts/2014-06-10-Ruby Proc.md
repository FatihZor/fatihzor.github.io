---
layout: post
title:  "Ruby Proc"
date:   2014-06-10 15:22:15
categories:  [Ruby]
tags:  [Rails]
---

# Proc #

Proc objects are blocks of code that have been bound to a set of local variables. Once bound, the code may be called in different contexts and still access those variables.

	def gen_times(factor)
	  return Proc.new {|n| n*factor }
	end
	
	times3 = gen_times(3)
	times5 = gen_times(5)
	
	times3.call(12)               #=> 36
	times5.call(5)                #=> 25
	times3.call(times5.call(4))   #=> 60

Another two ways to define Proc

	return Proc.new {|n| n*factor }

OR

	return proc {|n| n*factor}

Or

	return lambda {|n| n*factor}

Some of the functions:

call,lambda?,parameters,arity

##call ##

Invokes the block, setting the block’s parameters to the values in params using something close to method calling semantics. Generates a warning if multiple values are passed to a proc that expects just one (previously this silently converted the parameters to an array). Note that prc.() invokes prc.call() with the parameters given. It’s a syntax sugar to hide “call”.

### [] ###

the same as call

	a_proc = Proc.new {|a, *b| b.collect {|i| i*a }}
	a_proc.call(9, 1, 2, 3)   #=> [9, 18, 27]
	a_proc[9, 1, 2, 3]        #=> [9, 18, 27]
	a_proc = lambda {|a,b| a}
	a_proc.call(1,2,3)

### lambda?  ###

Returns true for a Proc object for which argument handling is rigid. Such procs are typically generated by lambda.

	lambda {}.lambda?            #=> true
	proc {}.lambda?              #=> false

###  parameters → array

Returns the parameter information of this proc.

	prc = lambda{|x, y=42, *other|}
	prc.parameters  #=> [[:req, :x], [:opt, :y], [:rest, :other]]

### arity → fixnum ###

Returns the number of arguments that would not be ignored. If the block is declared to take no arguments, returns 0. If the block is known to take exactly n arguments, returns n. If the block has optional arguments, return -n-1, where n is the number of mandatory arguments. A proc with no argument declarations is the same a block declaring || as its arguments.

	Proc.new {}.arity          #=>  0
	Proc.new {||}.arity        #=>  0
	Proc.new {|a|}.arity       #=>  1
	Proc.new {|a,b|}.arity     #=>  2
	Proc.new {|a,b,c|}.arity   #=>  3
	Proc.new {|*a|}.arity      #=> -1
	Proc.new {|a,*b|}.arity    #=> -2
	Proc.new {|a,*b, c|}.arity    #=> -3

### curry → a_proc ###

Returns a curried proc. If the optional arity argument is given, it determines the number of arguments. A curried proc receives some arguments. If a sufficient number of arguments are supplied, it passes the supplied arguments to the original proc and returns the result. Otherwise, returns another curried proc that takes the rest of arguments.

	b = proc {|x, y, z| (x||0) + (y||0) + (z||0) }
	p b.curry[1][2][3]           #=> 6
	p b.curry[1, 2][3, 4]        #=> 6
	p b.curry(5)[1][2][3][4][5]  #=> 6
	p b.curry(5)[1, 2][3, 4][5]  #=> 6
	p b.curry(1)[1]              #=> 1
	
	b = proc {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &:+) }
	p b.curry[1][2][3]           #=> 6
	p b.curry[1, 2][3, 4]        #=> 10
	p b.curry(5)[1][2][3][4][5]  #=> 15
	p b.curry(5)[1, 2][3, 4][5]  #=> 15
	p b.curry(1)[1]              #=> 1
	
	b = lambda {|x, y, z| (x||0) + (y||0) + (z||0) }
	p b.curry[1][2][3]           #=> 6
	p b.curry[1, 2][3, 4]        #=> wrong number of arguments (4 for 3)
	p b.curry(5)                 #=> wrong number of arguments (5 for 3)
	p b.curry(1)                 #=> wrong number of arguments (1 for 3)
	
	b = lambda {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &:+) }
	p b.curry[1][2][3]           #=> 6
	p b.curry[1, 2][3, 4]        #=> 10
	p b.curry(5)[1][2][3][4][5]  #=> 15
	p b.curry(5)[1, 2][3, 4][5]  #=> 15
	p b.curry(1)                 #=> wrong number of arguments (1 for 3)
	
	b = proc { :foo }
	p b.curry[]                  #=> :foo